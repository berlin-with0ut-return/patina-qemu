/** @file ConfigServiceGenerated.h

  Autogenerated configuration headers from mu_feature_config

  Copyright (c) Microsoft Corporation.
  SPDX-License-Identifier: BSD-2-Clause-Patent

**/

#ifndef CONFIGSERVICEGENERATED_H
#define CONFIGSERVICEGENERATED_H
#include <Library/PcdLib.h>
#include <Library/BaseMemoryLib.h>
// The config public header must be included prior to this file
// Generated Header
//  Script: C:\Users\sherryfan\patina-qemu\Features\CONFIG\SetupDataPkg\Tools\KnobService.py
//  Schema: C:\Users\sherryfan\patina-qemu\Platforms\QemuQ35Pkg\CfgData\QemuQ35PkgCfgData.xml

#define CACHED_POLICY_SIGNATURE    SIGNATURE_32 ('C', 'P', 'O', 'L')
#define CACHED_POLICY_HEADER_SIZE  sizeof (CACHED_POLICY_HEADER)

#define CACHED_POLICY_SIZE 0xe9

// Cached policy header, used to validate the cache internally
#pragma pack (1)

typedef struct {
  UINT32 Signature;
} CACHED_POLICY_HEADER;

#pragma pack ()

STATIC UINT8 CachedPolicy[CACHED_POLICY_SIZE + CACHED_POLICY_HEADER_SIZE];
STATIC_ASSERT(CACHED_POLICY_SIZE + CACHED_POLICY_HEADER_SIZE <= MAX_UINT16, "Config too large!");

STATIC
EFI_STATUS
InitConfigPolicyCache (
  UINT8   *Cache,
  UINT16  CacheSize
)
{
  EFI_STATUS Status;
  UINT16 ConfPolSize = CacheSize;

  Status = GetPolicy (PcdGetPtr (PcdConfigurationPolicyGuid), NULL, Cache + CACHED_POLICY_HEADER_SIZE, &ConfPolSize);
  if ((EFI_ERROR (Status)) || (ConfPolSize != CACHED_POLICY_SIZE)) {
    ASSERT (FALSE);
    return Status;
  }

  ((CACHED_POLICY_HEADER*)Cache)->Signature = CACHED_POLICY_SIGNATURE;

  return Status;
}

// Schema-defined knobs
// DummyKnob1 knob
// Get the current value of the DummyKnob1 knob from supplied cache
EFI_STATUS ConfigGetDummyKnob1FromCache (
  UINT32 *Knob,
  UINT8 *Cache,
  UINT16 CacheSize
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = CACHED_POLICY_HEADER_SIZE + 50;

  if ((Knob == NULL) || (Cache == NULL)) {
    return EFI_INVALID_PARAMETER;
  }

  if (((CACHED_POLICY_HEADER *)Cache)->Signature != CACHED_POLICY_SIGNATURE) {
    Status = InitConfigPolicyCache (Cache, CacheSize);
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(UINT32) > CacheSize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, Cache + Offset, sizeof (UINT32));
  return EFI_SUCCESS;
}

// Get the current value of the DummyKnob1 knob from cache
EFI_STATUS ConfigGetDummyKnob1 (
  UINT32 *Knob
  )
{
  return ConfigGetDummyKnob1FromCache (Knob, CachedPolicy, sizeof (CachedPolicy));
}

// DummyKnob2 knob
// Get the current value of the DummyKnob2 knob from supplied cache
EFI_STATUS ConfigGetDummyKnob2FromCache (
  UINT32 *Knob,
  UINT8 *Cache,
  UINT16 CacheSize
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = CACHED_POLICY_HEADER_SIZE + 108;

  if ((Knob == NULL) || (Cache == NULL)) {
    return EFI_INVALID_PARAMETER;
  }

  if (((CACHED_POLICY_HEADER *)Cache)->Signature != CACHED_POLICY_SIGNATURE) {
    Status = InitConfigPolicyCache (Cache, CacheSize);
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(UINT32) > CacheSize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, Cache + Offset, sizeof (UINT32));
  return EFI_SUCCESS;
}

// Get the current value of the DummyKnob2 knob from cache
EFI_STATUS ConfigGetDummyKnob2 (
  UINT32 *Knob
  )
{
  return ConfigGetDummyKnob2FromCache (Knob, CachedPolicy, sizeof (CachedPolicy));
}

// PowerOnPort0 knob
// Get the current value of the PowerOnPort0 knob from supplied cache
EFI_STATUS ConfigGetPowerOnPort0FromCache (
  BOOLEAN *Knob,
  UINT8 *Cache,
  UINT16 CacheSize
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = CACHED_POLICY_HEADER_SIZE + 170;

  if ((Knob == NULL) || (Cache == NULL)) {
    return EFI_INVALID_PARAMETER;
  }

  if (((CACHED_POLICY_HEADER *)Cache)->Signature != CACHED_POLICY_SIGNATURE) {
    Status = InitConfigPolicyCache (Cache, CacheSize);
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(BOOLEAN) > CacheSize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, Cache + Offset, sizeof (BOOLEAN));
  return EFI_SUCCESS;
}

// Get the current value of the PowerOnPort0 knob from cache
EFI_STATUS ConfigGetPowerOnPort0 (
  BOOLEAN *Knob
  )
{
  return ConfigGetPowerOnPort0FromCache (Knob, CachedPolicy, sizeof (CachedPolicy));
}

// DummyKnob3 knob
// Get the current value of the DummyKnob3 knob from supplied cache
EFI_STATUS ConfigGetDummyKnob3FromCache (
  UINT32 *Knob,
  UINT8 *Cache,
  UINT16 CacheSize
  )
{
  EFI_STATUS Status;
  CONST UINTN Offset = CACHED_POLICY_HEADER_SIZE + 225;

  if ((Knob == NULL) || (Cache == NULL)) {
    return EFI_INVALID_PARAMETER;
  }

  if (((CACHED_POLICY_HEADER *)Cache)->Signature != CACHED_POLICY_SIGNATURE) {
    Status = InitConfigPolicyCache (Cache, CacheSize);
    if (EFI_ERROR (Status)) {
      ASSERT (FALSE);
      return Status;
    }
  }

  if (Offset + sizeof(UINT32) > CacheSize) {
    ASSERT (FALSE);
    return EFI_COMPROMISED_DATA;
  }

  CopyMem(Knob, Cache + Offset, sizeof (UINT32));
  return EFI_SUCCESS;
}

// Get the current value of the DummyKnob3 knob from cache
EFI_STATUS ConfigGetDummyKnob3 (
  UINT32 *Knob
  )
{
  return ConfigGetDummyKnob3FromCache (Knob, CachedPolicy, sizeof (CachedPolicy));
}

#endif // CONFIGSERVICEGENERATED_H
